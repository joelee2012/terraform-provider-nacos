
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>provider: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/joelee2012/terraform-provider-nacos/internal/provider/data_source_configuration.go (64.3%)</option>
				
				<option value="file1">github.com/joelee2012/terraform-provider-nacos/internal/provider/data_source_configurations.go (75.0%)</option>
				
				<option value="file2">github.com/joelee2012/terraform-provider-nacos/internal/provider/data_source_namespace.go (76.2%)</option>
				
				<option value="file3">github.com/joelee2012/terraform-provider-nacos/internal/provider/data_source_namespaces.go (78.3%)</option>
				
				<option value="file4">github.com/joelee2012/terraform-provider-nacos/internal/provider/provider.go (69.2%)</option>
				
				<option value="file5">github.com/joelee2012/terraform-provider-nacos/internal/provider/resource_configuration.go (74.2%)</option>
				
				<option value="file6">github.com/joelee2012/terraform-provider-nacos/internal/provider/resource_namespace.go (68.3%)</option>
				
				<option value="file7">github.com/joelee2012/terraform-provider-nacos/internal/provider/testutil/helper.go (0.0%)</option>
				
				<option value="file8">github.com/joelee2012/terraform-provider-nacos/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"
        "strings"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
        "github.com/joelee2012/nacosctl/pkg/nacos"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ datasource.DataSource = &amp;ConfigurationDataSource{}

func NewConfigurationDataSource() datasource.DataSource <span class="cov10" title="234">{
        return &amp;ConfigurationDataSource{}
}</span>

// ConfigurationDataSource defines the data source implementation.
type ConfigurationDataSource struct {
        client *nacos.Client
}

// ConfigurationDataSourceModel describes the data source data model.
type ConfigurationDataSourceModel struct {
        ID               types.String `tfsdk:"id"`
        DataID           types.String `tfsdk:"data_id"`
        Group            types.String `tfsdk:"group"`
        Content          types.String `tfsdk:"content"`
        NamespaceID      types.String `tfsdk:"namespace_id"`
        Type             types.String `tfsdk:"type"`
        Md5              types.String `tfsdk:"md5"`
        EncryptedDataKey types.String `tfsdk:"encrypt_key"`
        AppName          types.String `tfsdk:"app_name"`
        CreateTime       types.Int64  `tfsdk:"create_time"`
        ModifyTime       types.Int64  `tfsdk:"modify_time"`
        Desc             types.String `tfsdk:"description"`
        Tags             types.Set    `tfsdk:"tags"`
}

func (d *ConfigurationDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="74">{
        resp.TypeName = req.ProviderTypeName + "_configuration"
}</span>

func (d *ConfigurationDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov9" title="150">{
        resp.Schema = schema.Schema{
                // This description is used by the documentation generator and the language server.
                MarkdownDescription: "Configuration data source",

                Attributes: map[string]schema.Attribute{
                        "data_id": schema.StringAttribute{
                                Required: true,
                        },
                        "group": schema.StringAttribute{
                                Required: true,
                        },
                        "namespace_id": schema.StringAttribute{
                                Optional: true,
                        },
                        "id": schema.StringAttribute{
                                Computed: true,
                        },
                        "content": schema.StringAttribute{
                                Computed: true,
                        },
                        "type": schema.StringAttribute{
                                Computed: true,
                        },
                        "md5": schema.StringAttribute{
                                Computed: true,
                        },
                        "encrypt_key": schema.StringAttribute{
                                Computed: true,
                        },
                        "app_name": schema.StringAttribute{
                                Computed: true,
                        },
                        "description": schema.StringAttribute{
                                Computed: true,
                        },
                        "tags": schema.SetAttribute{
                                ElementType: types.StringType,
                                Computed:    true,
                        },
                        "create_time": schema.Int64Attribute{
                                Computed: true,
                        },
                        "modify_time": schema.Int64Attribute{
                                Computed: true,
                        },
                },
        }

}</span>

func (d *ConfigurationDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov4" title="10">{
        // Prevent panic if the provider has not been configured.
        if req.ProviderData == nil </span><span class="cov3" title="4">{
                return
        }</span>

        <span class="cov3" title="6">client, ok := req.ProviderData.(*nacos.Client)

        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )

                return
        }</span>

        <span class="cov3" title="6">d.client = client</span>
}

func (d *ConfigurationDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov2" title="3">{
        var data ConfigurationDataSourceModel
        // // Read Terraform configuration data into the model
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov2" title="3">config, err := d.client.GetConfig(&amp;nacos.GetCSOpts{DataID: data.DataID.ValueString(), Group: data.Group.ValueString(), NamespaceID: data.NamespaceID.ValueString()})
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to Read Nacos configuration",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov2" title="3">data = ConfigurationDataSourceModel{
                ID:               types.StringValue(config.ID),
                DataID:           types.StringValue(config.DataID),
                Group:            types.StringValue(config.Group),
                Content:          types.StringValue(config.Content),
                NamespaceID:      types.StringValue(config.NamespaceId),
                Type:             types.StringValue(config.Type),
                Md5:              types.StringValue(config.Md5),
                EncryptedDataKey: types.StringValue(config.EncryptedDataKey),
                AppName:          types.StringValue(config.AppName),
                CreateTime:       types.Int64Value(config.CreateTime),
                ModifyTime:       types.Int64Value(config.ModifyTime),
                Desc:             types.StringValue(config.Desc),
        }
        if config.Tags != "" </span><span class="cov0" title="0">{
                tags, diags := types.SetValueFrom(ctx, types.StringType, strings.Split(config.Tags, ","))
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">data.Tags = tags</span>
        } else<span class="cov2" title="3"> {
                data.Tags = types.SetNull(types.StringType)
        }</span>
        // Write logs using the tflog package
        // Documentation: https://terraform.io/plugin/log
        <span class="cov2" title="3">tflog.Trace(ctx, "read a data source")

        // Save data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
        "github.com/joelee2012/nacosctl/pkg/nacos"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ datasource.DataSource = &amp;ConfigurationsDataSource{}

func NewConfigurationsDataSource() datasource.DataSource <span class="cov10" title="234">{
        return &amp;ConfigurationsDataSource{}
}</span>

// ConfigurationsDataSource defines the data source implementation.
type ConfigurationsDataSource struct {
        client *nacos.Client
}

// ConfigurationsDataSourceModel describes the data source data model.
type ConfigurationsDataSourceModel struct {
        NamespaceID types.String          `tfsdk:"namespace_id"`
        DataID      types.String          `tfsdk:"data_id"`
        Group       types.String          `tfsdk:"group"`
        Items       []*ConfigurationModel `tfsdk:"items"`
}

type ConfigurationModel struct {
        ID               types.String `tfsdk:"id"`
        DataID           types.String `tfsdk:"data_id"`
        Group            types.String `tfsdk:"group"`
        Content          types.String `tfsdk:"content"`
        NamespaceID      types.String `tfsdk:"namespace_id"`
        Type             types.String `tfsdk:"type"`
        Md5              types.String `tfsdk:"md5"`
        EncryptedDataKey types.String `tfsdk:"encrypt_key"`
        AppName          types.String `tfsdk:"app_name"`
        CreateTime       types.Int64  `tfsdk:"create_time"`
        ModifyTime       types.Int64  `tfsdk:"modify_time"`
        Desc             types.String `tfsdk:"description"`
        // Tags             types.Set    `tfsdk:"tags"`
}

func (d *ConfigurationsDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="74">{
        resp.TypeName = req.ProviderTypeName + "_configurations"
}</span>

func (d *ConfigurationsDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov9" title="150">{
        resp.Schema = schema.Schema{
                // This description is used by the documentation generator and the language server.
                MarkdownDescription: "Configuration data source",

                Attributes: map[string]schema.Attribute{
                        "data_id": schema.StringAttribute{
                                Optional: true,
                        },
                        "group": schema.StringAttribute{
                                Optional: true,
                        },
                        "namespace_id": schema.StringAttribute{
                                Optional: true,
                        },
                        "items": schema.ListNestedAttribute{
                                Computed: true,
                                NestedObject: schema.NestedAttributeObject{
                                        Attributes: map[string]schema.Attribute{
                                                "id": schema.StringAttribute{
                                                        Computed: true,
                                                },
                                                "data_id": schema.StringAttribute{
                                                        Computed: true,
                                                },
                                                "namespace_id": schema.StringAttribute{
                                                        Computed: true,
                                                },
                                                "group": schema.StringAttribute{
                                                        Computed: true,
                                                },
                                                "content": schema.StringAttribute{
                                                        Computed: true,
                                                },
                                                "type": schema.StringAttribute{
                                                        Computed: true,
                                                },
                                                "md5": schema.StringAttribute{
                                                        Optional: true,
                                                        Computed: true,
                                                },
                                                "encrypt_key": schema.StringAttribute{
                                                        Computed: true,
                                                },
                                                "app_name": schema.StringAttribute{
                                                        Computed: true,
                                                },
                                                "description": schema.StringAttribute{
                                                        Computed: true,
                                                },
                                                // "tags": schema.SetAttribute{
                                                //         ElementType: types.StringType,
                                                //         Computed:    true,
                                                // },
                                                "create_time": schema.Int64Attribute{
                                                        Computed: true,
                                                },
                                                "modify_time": schema.Int64Attribute{
                                                        Computed: true,
                                                },
                                        },
                                },
                        },
                },
        }

}</span>

func (d *ConfigurationsDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov4" title="10">{
        // Prevent panic if the provider has not been configured.
        if req.ProviderData == nil </span><span class="cov3" title="4">{
                return
        }</span>

        <span class="cov3" title="6">client, ok := req.ProviderData.(*nacos.Client)

        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )

                return
        }</span>

        <span class="cov3" title="6">d.client = client</span>
}

func (d *ConfigurationsDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov2" title="3">{
        var data ConfigurationsDataSourceModel
        // // Read Terraform configuration data into the model
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov2" title="3">allCs := new(nacos.ConfigList)
        var err error
        if data.DataID.IsNull() &amp;&amp; data.Group.IsNull() &amp;&amp; data.NamespaceID.IsNull() </span><span class="cov0" title="0">{
                allCs, err = d.client.ListAllConfig()
        }</span> else<span class="cov2" title="3"> if data.DataID.IsNull() </span><span class="cov0" title="0">{
                allCs, err = d.client.ListConfigInNs(data.NamespaceID.ValueString(), data.Group.ValueString())
        }</span> else<span class="cov2" title="3"> {
                allCs, err = d.client.ListConfig(&amp;nacos.ListCSOpts{DataID: data.DataID.ValueString(), Group: data.Group.ValueString(), NamespaceID: data.NamespaceID.ValueString()})
        }</span>
        <span class="cov2" title="3">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to Read Nacos configuration",
                        err.Error(),
                )
                return
        }</span>
        <span class="cov2" title="3">for _, config := range allCs.Items </span><span class="cov2" title="3">{
                data.Items = append(data.Items, &amp;ConfigurationModel{
                        ID:               types.StringValue(config.ID),
                        DataID:           types.StringValue(config.DataID),
                        Group:            types.StringValue(config.Group),
                        Content:          types.StringValue(config.Content),
                        NamespaceID:      types.StringValue(config.NamespaceId),
                        Type:             types.StringValue(config.Type),
                        Md5:              types.StringValue(config.Md5),
                        EncryptedDataKey: types.StringValue(config.EncryptedDataKey),
                        AppName:          types.StringValue(config.AppName),
                        CreateTime:       types.Int64Value(config.CreateTime),
                        ModifyTime:       types.Int64Value(config.ModifyTime),
                        Desc:             types.StringValue(config.Desc),
                        // Tags:             types.StringValue(config.Tags),
                })
        }</span>

        // Write logs using the tflog package
        // Documentation: https://terraform.io/plugin/log
        <span class="cov2" title="3">tflog.Trace(ctx, "read a data source")

        // Save data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
        "github.com/joelee2012/nacosctl/pkg/nacos"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ datasource.DataSource = &amp;NamespaceDataSource{}

func NewNamespaceDataSource() datasource.DataSource <span class="cov10" title="234">{
        return &amp;NamespaceDataSource{}
}</span>

// NamespaceDataSource defines the data source implementation.
type NamespaceDataSource struct {
        client *nacos.Client
}

type NamespaceDataSourceModel struct {
        NamespaceId types.String `tfsdk:"namespace_id"`
        Name        types.String `tfsdk:"name"`
        Description types.String `tfsdk:"description"`
        Quota       types.Int64  `tfsdk:"quota"`
        ConfigCount types.Int64  `tfsdk:"config_count"`
        Type        types.Int64  `tfsdk:"type"`
}

func (d *NamespaceDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="74">{
        resp.TypeName = req.ProviderTypeName + "_namespace"
}</span>

func (d *NamespaceDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov9" title="150">{
        resp.Schema = schema.Schema{
                // This description is used by the documentation generator and the language server.
                MarkdownDescription: "Namespace data source",

                Attributes: map[string]schema.Attribute{
                        "namespace_id": schema.StringAttribute{
                                Required: true,
                        },
                        "name": schema.StringAttribute{
                                Computed: true,
                        },
                        "description": schema.StringAttribute{
                                Computed: true,
                        },
                        "quota": schema.Int64Attribute{
                                Computed: true,
                        },
                        "type": schema.Int64Attribute{
                                Computed: true,
                        },
                        "config_count": schema.Int64Attribute{
                                Computed: true,
                        },
                },
        }

}</span>

func (d *NamespaceDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov4" title="10">{
        // Prevent panic if the provider has not been configured.
        if req.ProviderData == nil </span><span class="cov3" title="4">{
                return
        }</span>

        <span class="cov3" title="6">client, ok := req.ProviderData.(*nacos.Client)

        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )

                return
        }</span>

        <span class="cov3" title="6">d.client = client</span>
}

func (d *NamespaceDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov2" title="3">{
        var data NamespaceDataSourceModel
        // // Read Terraform configuration data into the model
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov2" title="3">ns, err := d.client.GetNamespace(data.NamespaceId.ValueString())
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to Read Nacos namespaces",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov2" title="3">data = NamespaceDataSourceModel{
                NamespaceId: types.StringValue(ns.ID),
                Name:        types.StringValue(ns.Name),
                Description: types.StringValue(ns.Description),
                Quota:       types.Int64Value(int64(ns.Quota)),
                Type:        types.Int64Value(int64(ns.Type)),
                ConfigCount: types.Int64Value(int64(ns.ConfigCount)),
        }

        // Write logs using the tflog package
        // Documentation: https://terraform.io/plugin/log
        tflog.Trace(ctx, "read a data source")

        // Save data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
        "github.com/joelee2012/nacosctl/pkg/nacos"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ datasource.DataSource = &amp;NamespacesDataSource{}

func NewNamespacesDataSource() datasource.DataSource <span class="cov10" title="234">{
        return &amp;NamespacesDataSource{}
}</span>

// NamespacesDataSource defines the data source implementation.
type NamespacesDataSource struct {
        client *nacos.Client
}

// NamespacesDataSourceModel describes the data source data model.
type NamespacesDataSourceModel struct {
        Namespaces []*NamespaceModel `tfsdk:"namespaces"`
}

type NamespaceModel struct {
        NamespaceId types.String `tfsdk:"namespace_id"`
        Name        types.String `tfsdk:"name"`
        Description types.String `tfsdk:"description"`
        Quota       types.Int64  `tfsdk:"quota"`
        ConfigCount types.Int64  `tfsdk:"config_count"`
        Type        types.Int64  `tfsdk:"type"`
}

func (d *NamespacesDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="74">{
        resp.TypeName = req.ProviderTypeName + "_namespaces"
}</span>

func (d *NamespacesDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov9" title="150">{
        resp.Schema = schema.Schema{
                // This description is used by the documentation generator and the language server.
                MarkdownDescription: "Namespaces data source",

                Attributes: map[string]schema.Attribute{
                        "namespaces": schema.ListNestedAttribute{
                                Computed: true,
                                NestedObject: schema.NestedAttributeObject{
                                        Attributes: map[string]schema.Attribute{
                                                "namespace_id": schema.StringAttribute{
                                                        Computed: true,
                                                },
                                                "name": schema.StringAttribute{
                                                        Computed: true,
                                                },
                                                "description": schema.StringAttribute{
                                                        Computed: true,
                                                },
                                                "quota": schema.Int64Attribute{
                                                        Computed: true,
                                                },
                                                "type": schema.Int64Attribute{
                                                        Computed: true,
                                                },
                                                "config_count": schema.Int64Attribute{
                                                        Computed: true,
                                                },
                                        },
                                },
                        },
                },
        }

}</span>

func (d *NamespacesDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov4" title="10">{
        // Prevent panic if the provider has not been configured.
        if req.ProviderData == nil </span><span class="cov3" title="4">{
                return
        }</span>

        <span class="cov3" title="6">client, ok := req.ProviderData.(*nacos.Client)

        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )

                return
        }</span>

        <span class="cov3" title="6">d.client = client</span>
}

func (d *NamespacesDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov2" title="3">{
        var data NamespacesDataSourceModel
        // // Read Terraform configuration data into the model
        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov2" title="3">namespaces, err := d.client.ListNamespace()
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to Read Nacos namespaces",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov2" title="3">for _, ns := range namespaces.Items </span><span class="cov3" title="6">{
                namespace := NamespaceModel{
                        NamespaceId: types.StringValue(ns.ID),
                        Name:        types.StringValue(ns.Name),
                        Description: types.StringValue(ns.Description),
                        Quota:       types.Int64Value(int64(ns.Quota)),
                        Type:        types.Int64Value(int64(ns.Type)),
                        ConfigCount: types.Int64Value(int64(ns.ConfigCount)),
                }
                data.Namespaces = append(data.Namespaces, &amp;namespace)
        }</span>

        // Write logs using the tflog package
        // Documentation: https://terraform.io/plugin/log
        <span class="cov2" title="3">tflog.Trace(ctx, "read a data source")

        // Save data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "os"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/provider"
        "github.com/hashicorp/terraform-plugin-framework/provider/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/joelee2012/nacosctl/pkg/nacos"
)

// Ensure ScaffoldingProvider satisfies various provider interfaces.
var _ provider.Provider = &amp;NacosProvider{}

// NacosProvider defines the provider implementation.
type NacosProvider struct {
        // version is set to the provider version on release, "dev" when the
        // provider is built and ran locally, and "test" when running acceptance
        // testing.
        version string
}

// NacosProviderModel describes the provider data model.
type NacosProviderModel struct {
        Host     types.String `tfsdk:"host"`
        Username types.String `tfsdk:"username"`
        Password types.String `tfsdk:"password"`
}

func (p *NacosProvider) Metadata(ctx context.Context, req provider.MetadataRequest, resp *provider.MetadataResponse) <span class="cov10" title="74">{
        resp.TypeName = "nacos"
        resp.Version = p.version
}</span>

func (p *NacosProvider) Schema(ctx context.Context, req provider.SchemaRequest, resp *provider.SchemaResponse) <span class="cov10" title="74">{
        resp.Schema = schema.Schema{
                Attributes: map[string]schema.Attribute{
                        "host": schema.StringAttribute{
                                MarkdownDescription: "URL of nacos server",
                                Optional:            true,
                        },
                        "username": schema.StringAttribute{
                                MarkdownDescription: "Username for nacos server",
                                Optional:            true,
                        },
                        "password": schema.StringAttribute{
                                MarkdownDescription: "Password for nacos server",
                                Optional:            true,
                        },
                },
        }
}</span>

func (p *NacosProvider) Configure(ctx context.Context, req provider.ConfigureRequest, resp *provider.ConfigureResponse) <span class="cov8" title="38">{
        var config NacosProviderModel

        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;config)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="38">if config.Host.IsUnknown() </span><span class="cov0" title="0">{
                resp.Diagnostics.AddAttributeError(
                        path.Root("host"),
                        "Unknown Nacos API Host",
                        "The provider cannot create the Nacos API client as there is an unknown configuration value for the Nacos API host. "+
                                "Either target apply the source of the value first, set the value statically in the configuration, or use the NACOS_HOST environment variable.",
                )
        }</span>

        <span class="cov8" title="38">if config.Username.IsUnknown() </span><span class="cov0" title="0">{
                resp.Diagnostics.AddAttributeError(
                        path.Root("username"),
                        "Unknown Nacos API Username",
                        "The provider cannot create the Nacos API client as there is an unknown configuration value for the Nacos API username. "+
                                "Either target apply the source of the value first, set the value statically in the configuration, or use the NACOS_USERNAME environment variable.",
                )
        }</span>

        <span class="cov8" title="38">if config.Password.IsUnknown() </span><span class="cov0" title="0">{
                resp.Diagnostics.AddAttributeError(
                        path.Root("password"),
                        "Unknown Nacos API Password",
                        "The provider cannot create the Nacos API client as there is an unknown configuration value for the Nacos API password. "+
                                "Either target apply the source of the value first, set the value statically in the configuration, or use the NACOS_PASSWORD environment variable.",
                )
        }</span>

        <span class="cov8" title="38">if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Default values to environment variables, but override
        // with Terraform configuration value if set.

        <span class="cov8" title="38">host := os.Getenv("NACOS_HOST")
        username := os.Getenv("NACOS_USERNAME")
        password := os.Getenv("NACOS_PASSWORD")

        if !config.Host.IsNull() </span><span class="cov0" title="0">{
                host = config.Host.ValueString()
        }</span>

        <span class="cov8" title="38">if !config.Username.IsNull() </span><span class="cov0" title="0">{
                username = config.Username.ValueString()
        }</span>

        <span class="cov8" title="38">if !config.Password.IsNull() </span><span class="cov0" title="0">{
                password = config.Password.ValueString()
        }</span>

        // If any of the expected configurations are missing, return
        // errors with provider-specific guidance.

        <span class="cov8" title="38">if host == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddAttributeError(
                        path.Root("host"),
                        "Missing Nacos API Host",
                        "The provider cannot create the Nacos API client as there is a missing or empty value for the Nacos API host. "+
                                "Set the host value in the configuration or use the NACOS_HOST environment variable. "+
                                "If either is already set, ensure the value is not empty.",
                )
        }</span>

        <span class="cov8" title="38">if username == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddAttributeError(
                        path.Root("username"),
                        "Missing Nacos API Username",
                        "The provider cannot create the Nacos API client as there is a missing or empty value for the Nacos API username. "+
                                "Set the username value in the configuration or use the NACOS_USERNAME environment variable. "+
                                "If either is already set, ensure the value is not empty.",
                )
        }</span>

        <span class="cov8" title="38">if password == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddAttributeError(
                        path.Root("password"),
                        "Missing Nacos API Password",
                        "The provider cannot create the Nacos API client as there is a missing or empty value for the Nacos API password. "+
                                "Set the password value in the configuration or use the NACOS_PASSWORD environment variable. "+
                                "If either is already set, ensure the value is not empty.",
                )
        }</span>

        <span class="cov8" title="38">if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Create a new HashiCups client using the configuration values
        <span class="cov8" title="38">client := nacos.NewClient(host, username, password)

        // Example client configuration for data sources and resources
        resp.DataSourceData = client
        resp.ResourceData = client</span>
}

func (p *NacosProvider) Resources(ctx context.Context) []func() resource.Resource <span class="cov10" title="74">{
        return []func() resource.Resource{
                NewNamespaceResource,
                NewConfigurationResource,
        }
}</span>

func (p *NacosProvider) DataSources(ctx context.Context) []func() datasource.DataSource <span class="cov10" title="74">{
        return []func() datasource.DataSource{
                NewNamespaceDataSource,
                NewNamespacesDataSource,
                NewConfigurationDataSource,
                NewConfigurationsDataSource,
        }
}</span>

func New(version string) func() provider.Provider <span class="cov2" title="2">{
        return func() provider.Provider </span><span class="cov2" title="2">{
                return &amp;NacosProvider{
                        version: version,
                }
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"
        "strings"

        "github.com/hashicorp/terraform-plugin-framework/diag"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/identityschema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
        "github.com/joelee2012/nacosctl/pkg/nacos"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &amp;ConfigurationResource{}
var _ resource.ResourceWithImportState = &amp;ConfigurationResource{}
var _ resource.ResourceWithIdentity = &amp;ConfigurationResource{}

func NewConfigurationResource() resource.Resource <span class="cov10" title="300">{
        return &amp;ConfigurationResource{}
}</span>

// ConfigurationResource defines the resource implementation.
type ConfigurationResource struct {
        client *nacos.Client
}

// ConfigurationResourceModel describes the resource data model.
type ConfigurationResourceModel struct {
        DataID           types.String `tfsdk:"data_id"`
        Group            types.String `tfsdk:"group"`
        Content          types.String `tfsdk:"content"`
        NamespaceID      types.String `tfsdk:"namespace_id"`
        Type             types.String `tfsdk:"type"`
        Application      types.String `tfsdk:"application"`
        Description      types.String `tfsdk:"description"`
        Tags             types.Set    `tfsdk:"tags"`
        ID               types.String `tfsdk:"id"`
        CreateTime       types.Int64  `tfsdk:"create_time"`
        Md5              types.String `tfsdk:"md5"`
        EncryptedDataKey types.String `tfsdk:"encrypt_key"`
        ModifyTime       types.Int64  `tfsdk:"modify_time"`
}

func (c *ConfigurationResourceModel) SetFromConfiguration(ctx context.Context, cfg *nacos.Config) diag.Diagnostics <span class="cov3" title="6">{
        c.Application = types.StringValue(cfg.AppName)
        c.Content = types.StringValue(cfg.Content)
        c.Description = types.StringValue(cfg.Desc)
        c.Type = types.StringValue(cfg.Type)
        c.ID = types.StringValue(cfg.ID)
        c.Md5 = types.StringValue(cfg.Md5)
        c.CreateTime = types.Int64Value(cfg.CreateTime)
        c.ModifyTime = types.Int64Value(cfg.ModifyTime)
        c.EncryptedDataKey = types.StringValue(cfg.EncryptedDataKey)
        var diags diag.Diagnostics
        if cfg.Tags != "" </span><span class="cov3" title="6">{
                tags, diags := types.SetValueFrom(ctx, types.StringType, strings.Split(cfg.Tags, ","))
                if diags.HasError() </span><span class="cov0" title="0">{
                        return diags
                }</span>
                <span class="cov3" title="6">c.Tags = tags</span>
        }
        <span class="cov3" title="6">return diags</span>
}

func (c *ConfigurationResourceModel) TagsToString(ctx context.Context) (string, diag.Diagnostics) <span class="cov2" title="2">{
        var diags diag.Diagnostics
        var tags []string
        elements := make([]types.String, 0, len(c.Tags.Elements()))
        diags.Append(c.Tags.ElementsAs(ctx, &amp;elements, false)...)
        if diags.HasError() </span><span class="cov0" title="0">{
                return "", diags
        }</span>
        <span class="cov2" title="2">for _, tag := range elements </span><span class="cov3" title="4">{
                tags = append(tags, tag.ValueString())
        }</span>
        <span class="cov2" title="2">return strings.Join(tags, ","), diags</span>
}
func (r *ConfigurationResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="94">{
        resp.TypeName = req.ProviderTypeName + "_configuration"
}</span>

func (r *ConfigurationResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="156">{
        resp.Schema = schema.Schema{
                // This description is used by the documentation generator and the language server.
                MarkdownDescription: "Configuration resource",

                Attributes: map[string]schema.Attribute{
                        "data_id": schema.StringAttribute{
                                Required: true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                },
                        },
                        "content": schema.StringAttribute{
                                Required: true,
                        },
                        "group": schema.StringAttribute{
                                Optional: true,
                                Computed: true,
                                Default:  stringdefault.StaticString("DEFAULT_GROUP"),
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                },
                        },
                        "namespace_id": schema.StringAttribute{
                                Optional: true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "type": schema.StringAttribute{
                                Optional: true,
                                Computed: true,
                                Default:  stringdefault.StaticString("text"),
                                // PlanModifiers: []planmodifier.String{
                                //         stringplanmodifier.UseStateForUnknown(),
                                // },
                        },
                        "application": schema.StringAttribute{
                                Optional: true,
                                Computed: true,
                                Default:  stringdefault.StaticString(""),
                                // PlanModifiers: []planmodifier.String{
                                //         stringplanmodifier.UseStateForUnknown(),
                                // },
                        },
                        "description": schema.StringAttribute{
                                Optional: true,
                                Computed: true,
                                Default:  stringdefault.StaticString(""),
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "tags": schema.SetAttribute{
                                ElementType: types.StringType,
                                Optional:    true,
                        },
                        "md5": schema.StringAttribute{
                                Computed: true,
                                // PlanModifiers: []planmodifier.String{
                                //         stringplanmodifier.UseStateForUnknown(),
                                // },
                        },
                        "encrypt_key": schema.StringAttribute{
                                Computed: true,
                                // PlanModifiers: []planmodifier.String{
                                //         stringplanmodifier.UseStateForUnknown(),
                                // },
                        },
                        "create_time": schema.Int64Attribute{
                                Computed: true,
                                // PlanModifiers: []planmodifier.Int64{
                                //         int64planmodifier.UseStateForUnknown(),
                                // },
                        },
                        "modify_time": schema.Int64Attribute{
                                Computed: true,
                                // PlanModifiers: []planmodifier.Int64{
                                //         int64planmodifier.UseStateForUnknown(),
                                // },
                        },
                        "id": schema.StringAttribute{
                                Computed: true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                },
        }
}</span>

func (r *ConfigurationResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov6" title="32">{
        // Prevent panic if the provider has not been configured.
        if req.ProviderData == nil </span><span class="cov4" title="7">{
                return
        }</span>

        <span class="cov6" title="25">client, ok := req.ProviderData.(*nacos.Client)

        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )

                return
        }</span>

        <span class="cov6" title="25">r.client = client</span>
}

func (r *ConfigurationResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov1" title="1">{
        var data ConfigurationResourceModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov1" title="1">tflog.Debug(ctx, fmt.Sprintf("read plan %#v", data))
        getOpts := &amp;nacos.GetCSOpts{
                DataID:      data.DataID.ValueString(),
                Group:       data.Group.ValueString(),
                NamespaceID: data.NamespaceID.ValueString(),
        }
        config, err := r.client.GetConfig(getOpts)
        if err == nil &amp;&amp; config != nil </span><span class="cov0" title="0">{
                key := fmt.Sprintf("%s,%s,%s", data.DataID.ValueString(), data.Group.ValueString(), data.NamespaceID.ValueString())
                resp.Diagnostics.AddError(
                        "Configuration already exists",
                        fmt.Sprintf("A configuration with data_id=%s,group=%s,namespace_id=%s already exists. "+
                                "Run `terraform import nacos_configuration.example %s` to manage it.", getOpts.DataID, getOpts.Group, getOpts.NamespaceID, key),
                )
                return
        }</span>
        <span class="cov1" title="1">opts := &amp;nacos.CreateCSOpts{
                DataID:      data.DataID.ValueString(),
                Group:       data.Group.ValueString(),
                Content:     data.Content.ValueString(),
                NamespaceID: data.NamespaceID.ValueString(),
                Type:        data.Type.ValueString(),
                AppName:     data.Application.ValueString(),
                Desc:        data.Description.ValueString(),
        }

        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov1" title="1">{
                tags, diags := data.TagsToString(ctx)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov1" title="1">opts.Tags = tags</span>
        }

        <span class="cov1" title="1">err = r.client.CreateConfig(opts)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to Create Nacos configuration",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov1" title="1">config, err = r.client.GetConfig(getOpts)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to Read Nacos configuration when create resource",
                        err.Error(),
                )
                return
        }</span>
        <span class="cov1" title="1">resp.Diagnostics.Append(data.SetFromConfiguration(ctx, config)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov1" title="1">tflog.Debug(ctx, fmt.Sprintf("create resource %#v", data))
        // Save data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *ConfigurationResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov3" title="4">{
        var data ConfigurationResourceModel

        // Read Terraform prior state data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov3" title="4">tflog.Debug(ctx, fmt.Sprintf("read state %#v", data))

        config, err := r.client.GetConfig(&amp;nacos.GetCSOpts{
                DataID:      data.DataID.ValueString(),
                Group:       data.Group.ValueString(),
                NamespaceID: data.NamespaceID.ValueString(),
        })
        if err != nil </span><span class="cov0" title="0">{
                if IsNotFoundError(err) </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError(
                        "Unable to Read Nacos configuration",
                        err.Error(),
                )
                return</span>
        }

        <span class="cov3" title="4">resp.Diagnostics.Append(data.SetFromConfiguration(ctx, config)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov3" title="4">tflog.Debug(ctx, fmt.Sprintf("refresh resource %#v", data))
        // Save updated data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *ConfigurationResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov1" title="1">{
        var data ConfigurationResourceModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov1" title="1">tflog.Debug(ctx, fmt.Sprintf("read plan %#v", data))

        opts := &amp;nacos.CreateCSOpts{
                DataID:      data.DataID.ValueString(),
                Group:       data.Group.ValueString(),
                Content:     data.Content.ValueString(),
                NamespaceID: data.NamespaceID.ValueString(),
                Type:        data.Type.ValueString(),
                AppName:     data.Application.ValueString(),
                Desc:        data.Description.ValueString(),
        }

        if !data.Tags.IsNull() &amp;&amp; !data.Tags.IsUnknown() </span><span class="cov1" title="1">{
                tags, diags := data.TagsToString(ctx)
                resp.Diagnostics.Append(diags...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov1" title="1">opts.Tags = tags</span>
        }
        <span class="cov1" title="1">err := r.client.CreateConfig(opts)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to Update Nacos namespaces",
                        err.Error(),
                )
                return
        }</span>
        <span class="cov1" title="1">config, err := r.client.GetConfig(&amp;nacos.GetCSOpts{
                DataID:      data.DataID.ValueString(),
                Group:       data.Group.ValueString(),
                NamespaceID: data.NamespaceID.ValueString(),
        })
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to Read Nacos configuration when update resource",
                        err.Error(),
                )
                return
        }</span>
        <span class="cov1" title="1">resp.Diagnostics.Append(data.SetFromConfiguration(ctx, config)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov1" title="1">tflog.Debug(ctx, fmt.Sprintf("update resource %#v", data))
        // Save updated data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *ConfigurationResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov1" title="1">{
        var data ConfigurationResourceModel

        // Read Terraform prior state data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov1" title="1">opts := &amp;nacos.DeleteCSOpts{
                DataID:      data.DataID.ValueString(),
                Group:       data.Group.ValueString(),
                NamespaceID: data.NamespaceID.ValueString(),
        }
        err := r.client.DeleteConfig(opts)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to Delete Nacos configuration",
                        err.Error(),
                )
                return
        }</span>
}

func (r *ConfigurationResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov1" title="1">{
        idParts := strings.Split(req.ID, ":")

        if len(idParts) != 3 || idParts[0] == "" || idParts[1] == "" || idParts[2] == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Import Identifier",
                        fmt.Sprintf("Expected import identifier with format: namespace_id:group:data_id. Got: %q", req.ID),
                )
                return
        }</span>

        <span class="cov1" title="1">resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace_id"), idParts[0])...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("group"), idParts[1])...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("data_id"), idParts[2])...)</span>
}

// Struct model for identity data handling
type ConfigurationResourceIdentityModel struct {
        ID types.String `tfsdk:"id"`
}

func (r *ConfigurationResource) IdentitySchema(_ context.Context, _ resource.IdentitySchemaRequest, resp *resource.IdentitySchemaResponse) <span class="cov4" title="10">{
        resp.IdentitySchema = identityschema.Schema{
                Attributes: map[string]identityschema.Attribute{
                        "id": identityschema.StringAttribute{
                                RequiredForImport: true, // must be set during import by the practitioner
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package provider

import (
        "context"
        "fmt"
        "strings"

        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/identityschema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
        "github.com/joelee2012/nacosctl/pkg/nacos"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &amp;NamespaceResource{}
var _ resource.ResourceWithImportState = &amp;NamespaceResource{}
var _ resource.ResourceWithIdentity = &amp;NamespaceResource{}

func NewNamespaceResource() resource.Resource <span class="cov10" title="300">{
        return &amp;NamespaceResource{}
}</span>

// NamespaceResource defines the resource implementation.
type NamespaceResource struct {
        client *nacos.Client
}

// NamespaceResourceModel describes the resource data model.
type NamespaceResourceModel struct {
        Description types.String `tfsdk:"description"`
        Name        types.String `tfsdk:"name"`
        NamespaceId types.String `tfsdk:"namespace_id"`
}

func (r *NamespaceResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="94">{
        resp.TypeName = req.ProviderTypeName + "_namespace"
}</span>

func (r *NamespaceResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="156">{
        resp.Schema = schema.Schema{
                // This description is used by the documentation generator and the language server.
                MarkdownDescription: "Example resource",

                Attributes: map[string]schema.Attribute{
                        "namespace_id": schema.StringAttribute{
                                Required: true,
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                                MarkdownDescription: "Example identifier",
                        },
                        "name": schema.StringAttribute{
                                MarkdownDescription: "Example configurable attribute with default value",
                                Required:            true,
                        },
                        "description": schema.StringAttribute{
                                MarkdownDescription: "Example configurable attribute",
                                Optional:            true,
                                // Computed:            true,
                        },
                },
        }
}</span>

func (r *NamespaceResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov6" title="32">{
        // Prevent panic if the provider has not been configured.
        if req.ProviderData == nil </span><span class="cov4" title="7">{
                return
        }</span>

        <span class="cov6" title="25">client, ok := req.ProviderData.(*nacos.Client)

        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        fmt.Sprintf("Expected *http.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
                )

                return
        }</span>

        <span class="cov6" title="25">r.client = client</span>
}

func (r *NamespaceResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov1" title="1">{
        var data NamespaceResourceModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov1" title="1">config, err := r.client.GetNamespace(data.NamespaceId.ValueString())
        if err == nil &amp;&amp; config != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Namespace already exists",
                        fmt.Sprintf("A namespace with namespace_id=%s already exists. "+
                                "Run `terraform import nacos_namespace.example %s` to manage it.", data.NamespaceId.ValueString(), data.NamespaceId.ValueString()),
                )
                return
        }</span>

        <span class="cov1" title="1">opts := &amp;nacos.CreateNSOpts{
                ID:          data.NamespaceId.ValueString(),
                Name:        data.Name.ValueString(),
                Description: data.Description.ValueString(),
        }

        err = r.client.CreateNamespace(opts)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to Create Nacos namespaces",
                        err.Error(),
                )
                return
        }</span>

        // Write logs using the tflog package
        // Documentation: https://terraform.io/plugin/log
        <span class="cov1" title="1">tflog.Trace(ctx, "created a resource")

        // Save data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>

        // Set data returned by API in identity
        // identity := NamespaceResourceIdentityModel{
        //         ID: types.StringValue(opts.ID),
        // }
        // resp.Diagnostics.Append(resp.Identity.Set(ctx, &amp;identity)...)
}

func IsNotFoundError(err error) bool <span class="cov0" title="0">{
        return strings.HasPrefix(err.Error(), "404 Not Found")
}</span>

func (r *NamespaceResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov3" title="4">{
        var data NamespaceResourceModel

        // Read Terraform prior state data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov3" title="4">ns, err := r.client.GetNamespace(data.NamespaceId.ValueString())
        if err != nil </span><span class="cov0" title="0">{
                if IsNotFoundError(err) </span><span class="cov0" title="0">{
                        resp.State.RemoveResource(ctx)
                }</span>
                <span class="cov0" title="0">resp.Diagnostics.AddError(
                        "Unable to Read Nacos namespaces",
                        err.Error(),
                )
                return</span>
        }

        <span class="cov3" title="4">data.Name = types.StringValue(ns.Name)
        data.Description = types.StringValue(ns.Description)
        data.NamespaceId = types.StringValue(ns.ID)

        // Save updated data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *NamespaceResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov1" title="1">{
        var data NamespaceResourceModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov1" title="1">opts := &amp;nacos.CreateNSOpts{
                ID:          data.NamespaceId.ValueString(),
                Name:        data.Name.ValueString(),
                Description: data.Description.ValueString(),
        }
        err := r.client.UpdateNamespace(opts)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to Create Nacos namespaces",
                        err.Error(),
                )
                return
        }</span>

        // Save updated data into Terraform state
        <span class="cov1" title="1">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *NamespaceResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov1" title="1">{
        var data NamespaceResourceModel

        // Read Terraform prior state data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov1" title="1">err := r.client.DeleteNamespace(data.NamespaceId.ValueString())
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to Create Nacos namespaces",
                        err.Error(),
                )
                return
        }</span>
}

func (r *NamespaceResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov1" title="1">{
        resource.ImportStatePassthroughWithIdentity(ctx, path.Root("namespace_id"), path.Root("namespace_id"), req, resp)
}</span>

// Struct model for identity data handling
type NamespaceResourceIdentityModel struct {
        ID types.String `tfsdk:"namespace_id"`
}

func (r *NamespaceResource) IdentitySchema(_ context.Context, _ resource.IdentitySchemaRequest, resp *resource.IdentitySchemaResponse) <span class="cov4" title="10">{
        resp.IdentitySchema = identityschema.Schema{
                Attributes: map[string]identityschema.Attribute{
                        "namespace_id": identityschema.StringAttribute{
                                RequiredForImport: true, // must be set during import by the practitioner
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package testutil

import (
        "os"
        "testing"

        "github.com/joelee2012/nacosctl/pkg/nacos"
)

var client = nacos.NewClient(os.Getenv("NACOS_HOST"), os.Getenv("NACOS_USERNAME"), os.Getenv("NACOS_PASSWORD"))

func CreateConfiguration(t *testing.T, opts *nacos.CreateCSOpts) <span class="cov0" title="0">{
        if err := client.CreateConfig(opts); err != nil </span><span class="cov0" title="0">{
                t.Errorf("Error creating %s:%s:%s: %s", opts.NamespaceID, opts.Group, opts.DataID, err.Error())
        }</span>
        <span class="cov0" title="0">t.Cleanup(func() </span><span class="cov0" title="0">{
                if err := client.DeleteConfig(&amp;nacos.DeleteCSOpts{NamespaceID: opts.NamespaceID, DataID: opts.DataID, Group: opts.Group}); err != nil </span><span class="cov0" title="0">{
                        t.Errorf("Error deleting %s:%s:%s: %s", opts.NamespaceID, opts.Group, opts.DataID, err.Error())
                }</span>
        })
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package main

import (
        "context"
        "flag"
        "log"

        "github.com/joelee2012/terraform-provider-nacos/internal/provider"

        "github.com/hashicorp/terraform-plugin-framework/providerserver"
)

var (
        // these will be set by the goreleaser configuration
        // to appropriate values for the compiled binary.
        version string = "dev"

        // goreleaser can pass other information to the main package, such as the specific commit
        // https://goreleaser.com/cookbooks/using-main.version/
)

func main() <span class="cov0" title="0">{
        var debug bool

        flag.BoolVar(&amp;debug, "debug", false, "set to true to run the provider with support for debuggers like delve")
        flag.Parse()

        opts := providerserver.ServeOpts{
                // TODO: Update this string with the published name of your provider.
                // Also update the tfplugindocs generate command to either remove the
                // -provider-name flag or set its value to the updated provider name.
                Address: "registry.terraform.io/joelee2012/nacos",
                Debug:   debug,
        }

        err := providerserver.Serve(context.Background(), provider.New(version), opts)

        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err.Error())
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
